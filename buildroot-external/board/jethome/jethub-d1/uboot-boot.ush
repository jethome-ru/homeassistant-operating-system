
################################
setenv mmc_dev 1
setenv boot_part 0x6
setenv kernel_part_a 0x8
setenv kernel_part_b 0x10
setenv bootstate_blk 0x66000
setenv bootstate_size 0x10000
setenv bootstate_blocks 0x80
setenv bootstate_ram 0x0FFE0000

setenv dtb_mem_addr 0x10000000
setenv kernel_addr  0x11000000
setenv ramdisk_addr 0x13000000
setenv LINUX /Image
setenv FDT /meson-axg-jethome-jethub-j100.dtb
setenv bootargs "rootfstype=squashfs ro rootwait console=ttyAML0,115200n8 console=serial no_console_suspend consoleblank=0 fsck.fix=yes fsck.repair=yes net.ifnames=0 zram.enabled=1 zram.num_devices=3 apparmor=1 security=apparmor systemd.machine_id=${MACHINE_ID} cgroup_enable=memory"
setenv bootargs_a "root=/dev/mmcblk1p9"
setenv bootargs_b "root=/dev/mmcblk1p11"

setenv loadbootstate " \
    echo 'loading env...'; \
    mmc read ${bootstate_ram} ${bootstate_blk} ${bootstate_blocks}; \
    env import ${bootstate_ram} ${bootstate_size};"
setenv storebootstate " \
    echo 'storing env...'; \
    env export -c -s ${bootstate_size} ${bootstate_ram} BOOT_ORDER BOOT_A_LEFT BOOT_B_LEFT MACHINE_ID; \
    mmc write ${bootstate_ram} ${bootstate_blk} ${bootstate_blocks}; \
    saveenv;"

mmc dev ${mmc_dev}; 

run loadbootstate; 

test ${BOOT_ORDER} -ge 0 || setenv BOOT_ORDER 'A B'; 
test ${BOOT_A_LEFT} -ge 0 || setenv BOOT_A_LEFT 3; 
test ${BOOT_B_LEFT} -ge 0 || setenv BOOT_B_LEFT 3; 
setenv bootargs;
setenv BOOT_SLOT;

############### Check A/B slot

for BOOT_SLOT in ${BOOT_ORDER}; do
if test "z${bootargs}" != "z" ; then
     true;
elif test ""x${BOOT_SLOT}"" = ""xA""; then  
  if test ${BOOT_A_LEFT} -gt 0; then
    if test ${BOOT_A_LEFT} -eq 3; then
      setenv BOOT_A_LEFT 2;
    elif test ${BOOT_A_LEFT} -eq 2; then
      setenv BOOT_A_LEFT 1;
    elif test ${BOOT_A_LEFT} -eq 1; then
      setenv BOOT_A_LEFT 0;
    fi;
    echo "Trying to boot slot A, ${BOOT_A_LEFT} attempts remaining. Loading kernel ...";
    if ext4load mmc ${mmc_dev}:${kernel_part_a} ${kernel_addr} ${LINUX}; then
      if fatload mmc ${mmc_dev}:${boot_part} ${dtb_mem_addr} ${FDT}; then
        fdt addr ${dtb_mem_addr};
        setenv bootargs ${bootargs} ${bootargs_a} rauc.slot=A mac=${mac} ${cmdline};
      fi;
    fi;
  fi;
elif test ""x${BOOT_SLOT}"" = ""xB""; then
  if test ${BOOT_B_LEFT} -gt 0; then
    if test ${BOOT_B_LEFT} -eq 3; then
      setenv BOOT_B_LEFT 2;
    elif test ${BOOT_B_LEFT} -eq 2; then
      setenv BOOT_B_LEFT 1;
    elif test ${BOOT_B_LEFT} -eq 1; then
      setenv BOOT_B_LEFT 0;
    fi;
    echo "Trying to boot slot B, ${BOOT_B_LEFT} attempts remaining. Loading kernel ...";
    if ext4load mmc ${mmc_dev}:${kernel_part_b} ${kernel_addr} ${LINUX}; then
      if fatload mmc ${mmc_dev}:${boot_part} ${dtb_mem_addr} ${FDT}; then
        fdt addr ${dtb_mem_addr};
        setenv bootargs ${bootargs} ${bootargs_b} rauc.slot=B mac=${mac}  ${cmdline};
      fi;
    fi;
  fi;
fi;
done;

printenv bootargs;
if test \"z${bootargs}\" = \"z\" ; then
   echo No valid slot found, resetting tries to 3;
   setenv BOOT_A_LEFT 3;
   setenv BOOT_B_LEFT 3;
   run storebootstate;
   reset;
fi;
run storebootstate;
echo Starting kernel;
booti ${kernel_addr} - ${dtb_mem_addr};
echo "Boot failed, resetting...";
reset
